// Generated by CoffeeScript 1.3.1

/*
HLF Tip jQuery Plugin v1.2
Released under the MIT License
Written with jQuery 1.7.2
*/


(function() {
  var $, SnapTip, Tip, ns,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  $ = jQuery;

  ns = $.hlf;

  /*
  Tip
  ---
  Basic tooltip plugin with fading. Fades in and out based on give delays. Awake
  and asleep states can be read and are set after fade animations. This plugin
  requires css display logic for the classes. The API class has hooks; delegation
  is used instead of events due to call frequency.
  
  The tip object is shared by the input jQuery collection.
  
  Options:
  
  - `ms.duration`- Duration of sleep and wake animations.
  - `ms.delay` - Delay before sleeping and waking.
  - `cls.stem` - Empty to remove the stem.
  - `cls.follow` - Empty to disable cursor following.
  */


  ns.tip = {
    debug: true,
    toString: function(context) {
      switch (context) {
        case 'event':
          return '.hlf.tip';
        case 'data':
          return 'hlfTip';
        case 'class':
          return 'js-tips';
        case 'log':
          return 'hlf-tip:';
        default:
          return 'hlf.tip';
      }
    },
    defaults: (function(pre) {
      return {
        ms: {
          duration: {
            "in": 300,
            out: 300
          },
          delay: {
            "in": 300,
            out: 300
          }
        },
        cursorHeight: 6,
        dir: ['south', 'east'],
        cls: (function() {
          var cls;
          cls = {};
          _.each(['inner', 'content', 'stem', 'north', 'east', 'south', 'west', 'follow', 'trigger'], function(key) {
            return cls[key] = "" + pre + key;
          });
          cls.tip = 'js-tip';
          return cls;
        })()
      };
    })('js-tip-')
  };

  /*
  Snap-Tip
  --------
  
  The tip object is shared by the input jQuery collection.
  
  Options:
  
  - `snap.xSnap`- Set empty to disable snapping along x-axis. Off by default.
  - `snap.ySnap`- Set empty to disable snapping along y-axis. Off by default.
  - `snap.snap` - Set empty to disable snapping to trigger. Builds on top of
    axis-snapping. Off by default.
  */


  ns.snapTip = {
    debug: true,
    toString: function(context) {
      switch (context) {
        case 'event':
          return '.hlf.snapTip';
        case 'data':
          return 'hlfSnapTip';
        case 'class':
          return 'js-snap-tips';
        case 'log':
          return 'hlf-snap-tip:';
        default:
          return 'hlf.snapTip';
      }
    },
    defaults: (function(pre) {
      return $.extend(true, {}, ns.tip.defaults, {
        snap: {
          toTrigger: true,
          toXAxis: false,
          toYAxis: false
        },
        cls: (function() {
          var cls;
          cls = {
            snap: {}
          };
          _.each({
            toXAxis: 'x-side',
            toYAxis: 'y-side',
            toTrigger: 'trigger'
          }, function(val, key) {
            return cls.snap[key] = "" + pre + val;
          });
          cls.tip = 'js-tip js-snap-tip';
          return cls;
        })()
      });
    })('js-snap-tip-')
  };

  /*
  Tip API
  -------
  */


  Tip = (function() {

    Tip.name = 'Tip';

    function Tip($ts, o, $ctx) {
      var _this = this;
      this.$ts = $ts;
      this.o = o;
      this.$ctx = $ctx;
      _.bindAll(this, '_onTriggerMouseMove');
      this.$tip = $('<div>');
      this.doStem = this.o.cls.stem !== '';
      this.doFollow = this.o.cls.follow !== '';
      this._state = 'truehidden';
      this._p = {
        $t: null
      };
      this.$ts.each(function(idx, el) {
        var $t;
        $t = $(el);
        $t.addClass(_this.o.cls.trigger);
        _this._saveTriggerContent($t);
        return _this._bindTrigger($t);
      });
      this._render();
      this._bind();
    }

    Tip.prototype._defaultHtml = function() {
      var c, cDir, containerClass, html, stemHtml,
        _this = this;
      c = this.o.cls;
      cDir = $.trim(_.reduce(this.o.dir, (function(cls, dir) {
        return "" + cls + " " + c[dir];
      }), ''));
      containerClass = $.trim([c.tip, c.follow, cDir].join(' '));
      if (this.doStem === true) {
        stemHtml = "<div class='" + c.stem + "'></div>";
      }
      return html = "<div class=\"" + containerClass + "\">\n  <div class=\"" + c.inner + "\">\n    " + stemHtml + "\n    <div class=\"" + c.content + "\"></div>\n   </div>\n</div>";
    };

    Tip.prototype._saveTriggerContent = function($t) {
      var title;
      title = $t.attr('title');
      if (title) {
        return $t.data(this._dat('Content'), title).removeAttr('title');
      }
    };

    Tip.prototype._bindTrigger = function($t) {
      var _this = this;
      $t.on(this._evt('truemouseenter'), this._onTriggerMouseMove);
      $t.on(this._evt('truemouseleave'), function(evt) {
        return _this.sleepByTrigger($t);
      });
      if (this.doFollow === true) {
        return $t.on('mousemove', this._onTriggerMouseMove);
      }
    };

    Tip.prototype._bind = function() {
      var _this = this;
      return this.$tip.on('mouseenter', function(evt) {
        _this._log(_this._nsLog, 'enter tip');
        if (_this._p.$t != null) {
          _this._p.$t.data('hlfIsActive', true);
          return _this.wakeByTrigger(_this._p.$t);
        }
      }).on('mouseleave', function(evt) {
        _this._log(_this._nsLog, 'leave tip');
        if (_this._p.$t != null) {
          _this._p.$t.data('hlfIsActive', false);
          return _this.sleepByTrigger(_this._p.$t);
        }
      });
    };

    Tip.prototype._render = function() {
      var html, isCustom;
      if (this.$tip.html().length) {
        return false;
      }
      html = this.htmlOnRender();
      isCustom = (html != null) && html.length;
      if (!isCustom) {
        html = this._defaultHtml();
      }
      this.$tip = $(html).addClass(this.o.cls.follow);
      return this.$tip.prependTo(this.$ctx);
    };

    Tip.prototype._positionByTrigger = function($t) {
      return $t.trigger('mousemove');
    };

    Tip.prototype._inflateByTrigger = function($t) {
      return this.$tip.find("." + this.o.cls.content).text($t.data(this._dat('Content')));
    };

    Tip.prototype._onTriggerMouseMove = function(evt) {
      var $t,
        _this = this;
      if (!(evt.pageX != null)) {
        return false;
      }
      $t = ($t = $(evt.target)) && $t.hasClass(this.o.cls.trigger) ? $t : $t.closest(this.o.cls.trigger);
      if (!$t.length) {
        return false;
      }
      return this.wakeByTrigger($t, function() {
        var offset;
        offset = {
          top: evt.pageY,
          left: evt.pageX
        };
        offset = _this.offsetOnTriggerMouseMove(evt, offset, $t) || offset;
        offset.top += _this.o.cursorHeight;
        _this.$tip.css(offset);
        return _this._log(_this._nsLog, '_onTriggerMouseMove', _this.isAwake());
      });
    };

    Tip.prototype.options = function() {
      return this.o;
    };

    Tip.prototype.tip = function() {
      return this.$tip;
    };

    Tip.prototype.isAwake = function() {
      var _ref;
      return (_ref = this._state) === 'truevisible' || _ref === 'waking';
    };

    Tip.prototype.isAsleep = function() {
      var _ref;
      return (_ref = this._state) === 'truehidden' || _ref === 'sleeping';
    };

    Tip.prototype.isDir = function(dir) {
      return _.include(this.o.dir, dir);
    };

    Tip.prototype.wakeByTrigger = function($t, cb) {
      var delay, duration, initial,
        _this = this;
      initial = !$t.is(this._p.$t);
      if ((cb != null) && initial === false && this._state !== 'waking') {
        return cb();
      }
      if (this.isAwake() === true) {
        return false;
      }
      if (initial) {
        this._inflateByTrigger($t);
      }
      delay = this.o.ms.delay["in"];
      duration = this.o.ms.duration["in"];
      if (this._state === 'sleeping') {
        this._log(this._nsLog, 'clear sleep');
        clearTimeout(this._sleepCountdown);
        duration = delay = 50;
      }
      this._state = 'waking';
      this._wakeCountdown = setTimeout(function() {
        _this.onShow(initial);
        return _this.$tip.fadeIn(duration, function() {
          if (initial) {
            _this._p.$t = $t;
            if (cb != null) {
              cb();
            }
          }
          _this.afterShow(initial);
          return _this._state = 'truevisible';
        });
      }, delay);
      return true;
    };

    Tip.prototype.sleepByTrigger = function($t) {
      var _this = this;
      if (this._state !== 'truevisible') {
        return false;
      }
      this._state = 'sleeping';
      clearTimeout(this._wakeCountdown);
      this._sleepCountdown = setTimeout(function() {
        _this.onHide();
        return _this.$tip.fadeOut(_this.o.ms.duration.out, function() {
          _this._state = 'truehidden';
          return _this.afterHide();
        });
      }, this.o.ms.delay.out);
      return true;
    };

    Tip.prototype.onShow = function(initial) {};

    Tip.prototype.onHide = $.noop;

    Tip.prototype.afterShow = function(initial) {};

    Tip.prototype.afterHide = $.noop;

    Tip.prototype.htmlOnRender = $.noop;

    Tip.prototype.offsetOnTriggerMouseMove = function(evt, offset, $t) {
      return false;
    };

    return Tip;

  })();

  /*
  SnapTip API
  -----------
  */


  SnapTip = (function(_super) {

    __extends(SnapTip, _super);

    SnapTip.name = 'SnapTip';

    function SnapTip($ts, o, $ctx) {
      var _this = this;
      SnapTip.__super__.constructor.call(this, $ts, o, $ctx);
      this.o.snap.toTrigger = this.o.snap.toXAxis === true || this.o.snap.toYAxis === true;
      this._offsetStart = null;
      this.$ts.each(function(idx, el) {
        var trigger;
        trigger = $(el);
        return _this._bindTrigger(trigger);
      });
      _.each(this.o.snap, function(active, prop) {
        if (active) {
          return _this.$tip.addClass(_this.o.cls.snap[prop]);
        }
      });
    }

    SnapTip.prototype._moveToTrigger = function($t, baseOffset) {
      var offset;
      this._log(this._nsLog, baseOffset);
      offset = $t.offset();
      if (this.o.snap.toXAxis === true) {
        if (this.isDir('south')) {
          offset.top += $t.outerHeight();
        }
        if (this.o.snap.toYAxis === false) {
          offset.left = baseOffset.left - (this.$tip.outerWidth() - 12) / 2;
        }
      }
      if (this.o.snap.toYAxis === true) {
        if (this.isDir('east')) {
          offset.left += $t.outerWidth();
        }
        if (this.o.snap.toXAxis === false) {
          offset.top = baseOffset.top - $t.outerHeight() / 2;
        }
      }
      return offset;
    };

    SnapTip.prototype._bindTrigger = function($t) {
      var _this = this;
      SnapTip.__super__._bindTrigger.call(this, $t);
      return $t.on(this._evt('truemouseenter'), function(evt) {
        return _this._offsetStart = {
          top: evt.pageY,
          left: evt.pageX
        };
      }).on(this._evt('truemouseleave'), function(evt) {
        return _this._offsetStart = null;
      });
    };

    SnapTip.prototype.onShow = function(initial) {
      if (initial) {
        return this.$tip.css('visibility', 'hidden');
      }
    };

    SnapTip.prototype.afterShow = function(initial) {
      if (initial) {
        return this.$tip.css('visibility', 'visible');
      }
    };

    SnapTip.prototype.offsetOnTriggerMouseMove = function(evt, offset, $t) {
      var newOffset;
      newOffset = _.clone(offset);
      if (this.o.snap.toTrigger === true) {
        newOffset = this._moveToTrigger($t, newOffset);
      } else {
        if (this.o.snap.toXAxis === true) {
          newOffset.top = this._offsetStart.top;
          this._log(this._nsLog, 'xSnap');
        }
        if (this.o.snap.toYAxis === true) {
          newOffset.left = this._offsetStart.left;
          this._log(this._nsLog, 'ySnap');
        }
      }
      return newOffset;
    };

    return SnapTip;

  })(Tip);

  $.fn.tip = ns.createPlugin(ns.tip, Tip, true);

  $.fn.snapTip = ns.createPlugin(ns.snapTip, SnapTip, true);

}).call(this);
